name: Continuous Delivery

on:
  push:
    tags:
      - 'release/v*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Release version to promote (for example v1.2.3)'
        required: true
        type: string

env:
  REGISTRY: ghcr.io
  CHART_PATH: infra/helm/meetinity
  VALUES_PATH: infra/helm/meetinity/values
  K8S_ENV_PATH: infra/kubernetes/environments
  SERVICES: api-gateway user-service matching-service event-service

jobs:
  build:
    name: Build & publish ${{ matrix.service.name }}
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    strategy:
      matrix:
        service:
          - name: api-gateway
            context: services/api-gateway
          - name: user-service
            context: services/user-service
          - name: matching-service
            context: services/matching-service
          - name: event-service
            context: services/event-service
    outputs:
      release_version: ${{ steps.meta.outputs.release_version }}
      short_sha: ${{ steps.meta.outputs.short_sha }}
      owner: ${{ steps.meta.outputs.owner }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Determine release metadata
        id: meta
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            version="${{ inputs.version }}"
          else
            ref="${GITHUB_REF_NAME}"
            version="${ref#release/}"
          fi

          version="${version#refs/tags/}"
          if [ -z "$version" ]; then
            echo "Unable to determine release version" >&2
            exit 1
          fi

          short_sha="${GITHUB_SHA::7}"
          owner="${GITHUB_REPOSITORY_OWNER,,}"

          echo "release_version=$version" >> "$GITHUB_OUTPUT"
          echo "short_sha=$short_sha" >> "$GITHUB_OUTPUT"
          echo "owner=$owner" >> "$GITHUB_OUTPUT"

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build Docker image
        run: |
          owner="${{ steps.meta.outputs.owner }}"
          image_uri="${{ env.REGISTRY }}/$owner/${{ matrix.service.name }}"
          docker build \
            --build-arg GIT_SHA=${GITHUB_SHA} \
            --tag "$image_uri:${{ steps.meta.outputs.release_version }}" \
            --tag "$image_uri:sha-${{ steps.meta.outputs.short_sha }}" \
            "${{ matrix.service.context }}"

      - name: Push Docker image
        run: |
          owner="${{ steps.meta.outputs.owner }}"
          image_uri="${{ env.REGISTRY }}/$owner/${{ matrix.service.name }}"
          docker push "$image_uri:${{ steps.meta.outputs.release_version }}"
          docker push "$image_uri:sha-${{ steps.meta.outputs.short_sha }}"

  deploy-dev:
    name: Deploy to dev
    needs: build
    runs-on: ubuntu-latest
    environment:
      name: dev
      url: https://dev.meetinity.internal
    permissions:
      contents: read
      id-token: write
    env:
      RELEASE_NAME: meetinity-dev
      NAMESPACE: meetinity-dev
      VALUES_FILE: infra/helm/meetinity/values/dev.yaml
      ENVIRONMENT_KEY: dev
      K8S_MANIFEST: infra/kubernetes/environments/dev/namespace.yaml
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}
          mask-aws-account-id: true

      - name: Update kubeconfig for cluster
        run: |
          aws eks update-kubeconfig \
            --name ${{ secrets.EKS_CLUSTER_NAME }} \
            --region ${{ secrets.AWS_REGION }}

      - name: Apply namespace resources
        run: |
          kubectl apply -f "${K8S_MANIFEST}"

      - name: Create or update GHCR registry secret
        run: |
          kubectl create secret docker-registry ghcr-pull-secret \
            --namespace "${NAMESPACE}" \
            --docker-server=${{ env.REGISTRY }} \
            --docker-username=${{ secrets.GHCR_READER_USERNAME }} \
            --docker-password=${{ secrets.GHCR_READER_TOKEN }} \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy chart
        run: |
          owner="${{ needs.build.outputs.owner }}"
          version="${{ needs.build.outputs.release_version }}"
          extra_args=()
          for svc in $SERVICES; do
            extra_args+=(--set-string "${svc}.image.repository=${{ env.REGISTRY }}/$owner/${svc}")
            extra_args+=(--set-string "${svc}.image.tag=${version}")
          done

          helm upgrade --install "${RELEASE_NAME}" "${{ env.CHART_PATH }}" \
            --namespace "${NAMESPACE}" \
            --values "${{ env.CHART_PATH }}/values.yaml" \
            --values "${VALUES_FILE}" \
            --set-string global.environment="${ENVIRONMENT_KEY}" \
            "${extra_args[@]}" \
            --wait

      - name: Wait for workloads
        run: |
          for svc in $SERVICES; do
            kubectl rollout status deployment/"${svc}-${ENVIRONMENT_KEY}" \
              --namespace "${NAMESPACE}" \
              --timeout=5m
          done

  deploy-staging:
    name: Deploy to staging
    needs:
      - build
      - deploy-dev
    runs-on: ubuntu-latest
    environment:
      name: staging
      url: https://staging.meetinity.com
    permissions:
      contents: read
      id-token: write
    env:
      RELEASE_NAME: meetinity-staging
      NAMESPACE: meetinity-staging
      VALUES_FILE: infra/helm/meetinity/values/staging.yaml
      ENVIRONMENT_KEY: staging
      K8S_MANIFEST: infra/kubernetes/environments/staging/namespace.yaml
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}
          mask-aws-account-id: true

      - name: Update kubeconfig for cluster
        run: |
          aws eks update-kubeconfig \
            --name ${{ secrets.EKS_CLUSTER_NAME }} \
            --region ${{ secrets.AWS_REGION }}

      - name: Apply namespace resources
        run: |
          kubectl apply -f "${K8S_MANIFEST}"

      - name: Create or update GHCR registry secret
        run: |
          kubectl create secret docker-registry ghcr-pull-secret \
            --namespace "${NAMESPACE}" \
            --docker-server=${{ env.REGISTRY }} \
            --docker-username=${{ secrets.GHCR_READER_USERNAME }} \
            --docker-password=${{ secrets.GHCR_READER_TOKEN }} \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy chart
        run: |
          owner="${{ needs.build.outputs.owner }}"
          version="${{ needs.build.outputs.release_version }}"
          extra_args=()
          for svc in $SERVICES; do
            extra_args+=(--set-string "${svc}.image.repository=${{ env.REGISTRY }}/$owner/${svc}")
            extra_args+=(--set-string "${svc}.image.tag=${version}")
          done

          helm upgrade --install "${RELEASE_NAME}" "${{ env.CHART_PATH }}" \
            --namespace "${NAMESPACE}" \
            --values "${{ env.CHART_PATH }}/values.yaml" \
            --values "${VALUES_FILE}" \
            --set-string global.environment="${ENVIRONMENT_KEY}" \
            "${extra_args[@]}" \
            --wait

      - name: Wait for workloads
        run: |
          for svc in $SERVICES; do
            kubectl rollout status deployment/"${svc}-${ENVIRONMENT_KEY}" \
              --namespace "${NAMESPACE}" \
              --timeout=5m
          done

  deploy-prod:
    name: Deploy to prod
    needs:
      - build
      - deploy-staging
    runs-on: ubuntu-latest
    environment:
      name: production
      url: https://meetinity.com
    permissions:
      contents: read
      id-token: write
    env:
      RELEASE_NAME: meetinity-prod
      NAMESPACE: meetinity-prod
      VALUES_FILE: infra/helm/meetinity/values/prod.yaml
      ENVIRONMENT_KEY: prod
      K8S_MANIFEST: infra/kubernetes/environments/prod/namespace.yaml
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}
          mask-aws-account-id: true

      - name: Update kubeconfig for cluster
        run: |
          aws eks update-kubeconfig \
            --name ${{ secrets.EKS_CLUSTER_NAME }} \
            --region ${{ secrets.AWS_REGION }}

      - name: Apply namespace resources
        run: |
          kubectl apply -f "${K8S_MANIFEST}"

      - name: Create or update GHCR registry secret
        run: |
          kubectl create secret docker-registry ghcr-pull-secret \
            --namespace "${NAMESPACE}" \
            --docker-server=${{ env.REGISTRY }} \
            --docker-username=${{ secrets.GHCR_READER_USERNAME }} \
            --docker-password=${{ secrets.GHCR_READER_TOKEN }} \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy chart
        run: |
          owner="${{ needs.build.outputs.owner }}"
          version="${{ needs.build.outputs.release_version }}"
          extra_args=()
          for svc in $SERVICES; do
            extra_args+=(--set-string "${svc}.image.repository=${{ env.REGISTRY }}/$owner/${svc}")
            extra_args+=(--set-string "${svc}.image.tag=${version}")
          done

          helm upgrade --install "${RELEASE_NAME}" "${{ env.CHART_PATH }}" \
            --namespace "${NAMESPACE}" \
            --values "${{ env.CHART_PATH }}/values.yaml" \
            --values "${VALUES_FILE}" \
            --set-string global.environment="${ENVIRONMENT_KEY}" \
            "${extra_args[@]}" \
            --wait

      - name: Wait for workloads
        run: |
          for svc in $SERVICES; do
            kubectl rollout status deployment/"${svc}-${ENVIRONMENT_KEY}" \
              --namespace "${NAMESPACE}" \
              --timeout=5m
          done
