# Service Inventory (docker-compose.dev)

This document captures the development docker-compose stack and highlights build/runtime metadata needed for containerization work.

| Service | Repository / Image | Build Command | Runtime Entrypoint | Environment Variables | System Dependencies |
|---------|--------------------|---------------|--------------------|-----------------------|---------------------|
| `postgres` | `docker.io/postgres:15` | _Prebuilt image (no local build)_ | Default `docker-entrypoint.sh postgres` | `POSTGRES_USER`, `POSTGRES_PASSWORD`, `POSTGRES_DB` (defaults provided in compose) | Binds `${POSTGRES_PORT:-5432}` to host, persistent volume `postgres-data`, healthcheck `pg_isready`, requires `meetinity-net` bridge |
| `zookeeper` | `docker.io/bitnami/zookeeper:3.9` | _Prebuilt image_ | Bitnami default entrypoint (`/opt/bitnami/scripts/zookeeper/run.sh`) | `ZOO_ENABLE_AUTH=no`, `ALLOW_ANONYMOUS_LOGIN=yes` | Exposes `2181`, mounts `zookeeper-data`, joins `meetinity-net` |
| `kafka` | `docker.io/bitnami/kafka:3.5` | _Prebuilt image_ | Bitnami default entrypoint (`/opt/bitnami/scripts/kafka/run.sh`) | `KAFKA_BROKER_ID=1`, `KAFKA_CFG_ZOOKEEPER_CONNECT=zookeeper:2181`, `KAFKA_CFG_LISTENERS=PLAINTEXT://:9092`, `KAFKA_CFG_ADVERTISED_LISTENERS=PLAINTEXT://kafka:9092`, `ALLOW_PLAINTEXT_LISTENER=yes` | Maps `${KAFKA_PORT:-9092}`, persistent volume `kafka-data`, depends on `zookeeper`, healthcheck `kafka-topics.sh --list`, network `meetinity-net` |
| `kafka-ui` | `docker.io/provectuslabs/kafka-ui:latest` | _Prebuilt image_ | Default entrypoint (`/docker-entrypoint.sh`) serving web UI | `KAFKA_CLUSTERS_0_NAME=meetinity`, `KAFKA_CLUSTERS_0_BOOTSTRAPSERVERS=kafka:9092` | Publishes `${KAFKA_UI_PORT:-8085}`, depends on healthy `kafka`, network `meetinity-net` |
| `api-gateway` | `services/api-gateway` (Dockerfile) | `docker build ./services/api-gateway` | `gunicorn src.main:app` (configurable via `GUNICORN_*` env vars) | `.env.example` documents `APP_PORT`, `USER_SERVICE_URL`, `JWT_SECRET`, `CORS_ORIGINS`, `RATE_LIMIT_AUTH`, `LOG_LEVEL` | Needs Kafka & Postgres from compose; exposes `${API_GATEWAY_PORT:-8080}`, mounts `./services/api-gateway:/app`, curl-based healthcheck |
| `user-service` | `services/user-service` (Dockerfile) | `docker build ./services/user-service` | `alembic upgrade head && python -m gunicorn --bind 0.0.0.0:8080 'src.main:create_app()'` | `.env.example` covers OAuth creds, `DATABASE_URL`, pool tuning, Redis cache, JWT settings, `UPLOAD_*` paths | Requires Postgres (and optional Redis); publishes `${USER_SERVICE_PORT:-8081}`, runs DB migrations before boot, mounts `./services/user-service:/app` |
| `matching-service` | `services/matching-service` (Dockerfile) | `docker build ./services/matching-service` | `python -m gunicorn --bind 0.0.0.0:8080 src.main:create_app()` | `INFRASTRUCTURE.md` lists `DATABASE_URL`, Redis + Kafka endpoints, upstream service URLs, ML tuning knobs, CORS origins | Depends on Postgres, Redis, Kafka, model volume at `/app/models`; binds `${MATCHING_SERVICE_PORT:-8082}`, mounts `./services/matching-service:/app` |
| `event-service` | `services/event-service` (Dockerfile) | `docker build ./services/event-service` | `python -m gunicorn --bind 0.0.0.0:8080 src.main:create_app()` | README enumerates `DATABASE_URL` or `DB_*` fallbacks plus pool sizing overrides | Requires Postgres (SQLite fallback for local tests); publishes `${EVENT_SERVICE_PORT:-8083}`, mounts `./services/event-service:/app` |
| `messaging-service` | `services/messaging-service` (Dockerfile) | `docker build ./services/messaging-service` | `python -m gunicorn --bind 0.0.0.0:8080 src.main:create_app()` | Accepts `DATABASE_URL`/`DB_*` overrides (defaults to SQLite) for persistence; honours `FLASK_DEBUG` and standard Flask env vars | Requires Postgres in compose (SQLite for tests); exposes `${MESSAGING_SERVICE_PORT:-8084}`, mounts `./services/messaging-service:/app` |

## Notes & Follow-ups
- Application code for the five core services now lives under `services/`; the development compose file mounts these paths directly so local edits reflect immediately in running containers.
- Shared secrets are still injected via `.env.dev` (not committed). Each service also ships example configuration files (`.env.example`, `INFRASTRUCTURE.md`, README tables). Keep those sources in sync when onboarding new variables.
- The matching service persists trained models under `/app/models`; ensure the directory exists on the host if hot-reloading models outside Docker.
- Optional dependencies: the user service can leverage Redis for profile caching, and the matching service expects both Redis and Kafka endpointsâ€”disable or stub them in compose if they are not required for a particular workflow.

## Dockerfile hardening recap
- All service images now share a consistent multi-stage pattern with Python 3.11 slim bases, cached dependency installs, and isolated virtual environments.
- Runtime stages drop privileges to the `meetinity` user, include only the apt packages needed at runtime, and rely on `curl` health checks for readiness probes.
- Build arguments (`PYTHON_VERSION`, `GIT_SHA`) keep the images reproducible while allowing registry workflows to tag by semantic version and commit SHA.
