# API Strategy

Meetinity exposes a unified API surface that blends versioned REST endpoints with a federated GraphQL router. This document captures the lifecycle management policies and automation that keep both channels aligned.

## Lifecycle Management

### Versioning & Federation

* REST endpoints remain available under `/api/{version}` namespaces. Default routing continues to serve the `API_DEFAULT_VERSION`, while deprecation metadata is advertised through gateway headers and the developer portal.
* GraphQL traffic is handled by an Apollo-compatible router fronted by the API gateway. Subgraphs are declared through the `GRAPHQL_SUBGRAPHS` configuration and composed into a supergraph on start-up. The gateway validates that every proxied REST collection has a corresponding federated field before registering the GraphQL blueprint.
* Supergraph versions are hashed from subgraph SDL digests. The active version is emitted via the `api_gateway_graphql_supergraph_info` Prometheus gauge, enabling monitoring and deployment automation to track rollouts.

### Schema Composition & Contract Publication

* The gateway automatically composes subgraphs into a supergraph file at `services/api-gateway/deploy/graphql/supergraph.graphql` and writes a manifest with routing metadata to `contracts/graphql/graphql-supergraph.json`.
* CI/CD pipelines can force regeneration via `services/api-gateway/scripts/publish_contracts.py`. The script bootstraps the Flask app, triggers supergraph composition, and prints either JSON metadata or the supergraph path (`--print-path`) for shell-friendly usage.
* `infra/scripts/deploy.sh` consumes the published artifact and syncs it into a Kubernetes ConfigMap (`apollo-router-supergraph`) so Apollo Router instances always serve the latest contract.

### Rate Limits & Quotas

* REST endpoints inherit per-surface rate limits from `RATE_LIMIT_*` environment variables. GraphQL requests are throttled through the same limiter by sharing the gateway entry point, ensuring consistent protection across transport styles.
* API keys and JWT scopes define quota classes. Customer-facing plans map to keys with differing rate-limit buckets, while internal service-to-service traffic can be exempted via `API_KEY_EXEMPT_PATHS` and dedicated allow lists.

### Developer Portal & Onboarding

* The developer portal aggregates REST OpenAPI documents and GraphQL supergraph metadata. Contract artifacts generated by the gateway are published to the portal nightly, ensuring that new fields or deprecated routes are visible before they ship.
* Portal copy references the lifecycle expectations documented hereâ€”60 day heads-up on breaking REST changes, schema diff announcements for GraphQL, and links to the changelog for every supergraph version.

## Automation Summary

1. Declare subgraphs and mappings in environment configuration (`GRAPHQL_SUBGRAPHS`).
2. Run `services/api-gateway/scripts/publish_contracts.py` during CI to regenerate the supergraph and manifest.
3. Let `infra/scripts/deploy.sh` project the generated `supergraph.graphql` into Kubernetes; Apollo Router picks up changes through its mounted ConfigMap.
4. Observe `api_gateway_graphql_supergraph_info` in Prometheus to verify version rollouts and trigger alerts if an outdated contract persists.

This workflow keeps REST and GraphQL representations in sync, enables incremental schema evolution, and gives operators a single place to manage quotas, discoverability, and contract enforcement.
